[Contents](../personal_learning_record/personal_learning_record.md) | [Segment 1 - computer Arch](../personal_learning_record/segment1.md) 

# Segment 1 - Computer Architecture

---

**Segment 1 (Session 1-4 ) : Computer Architecture**

**_Introduction :_**

Our Tutor introduced me to the foundations and framework of how computers work. Essentially, it is designed to help me understand computer architecture in preparation for a degree in computing.

**Session 1:**

In this session, Tutor explained how to do an assessment, and I would be required to submit a Personal Learning Record. Though I had missed five weeks of class, the tutor explained to me what GitHub was. This subject was completely new to me, he went on to show me how to set up GitHub, create public and private keys. I learnt that GitHub is a web-based platform used by developers to host or manage repository codes using Git. Git is a version control that keeps a record of any changes made to a file. GitHub is also used by companies or individual developers. Tutor introduced me to GitHub jargon such as “repositories” and I researched and found out that it is the section where project files are stored and managed. GitHub also allows collaboration, meaning several users can work on projects at the same. Multiple users can manage contributions or changes within the same platform. Git was invented by Linus Torvalds that also work on big projects like Linux Kernel. Tutor taught and informed us that GitHub is now owned by Microsoft and many programmers and organisations are using it as home for their code. In the session, we were provided with examples and shown how the account looked like.

Tutor introduced me to the history and origins of computers.

**History Of Computers:**

The history of computers is quite an interesting read. Abacus is one of the earliest devices that was used for arithmetic. It has its ancient origins in ancient Sumeria and Babylon.

<https://www.google.com/url?q=https://www.linkedin.com/pulse/evolution-computers-from-abacus-artificial-shalini-sivakumar&sa=U&sqi=2&ved=2ahUKEwiBsfKN8uOKAxXKYEEAHVoaKG8QFnoECFoQAQ&usg=AOvVaw1oWyuA6pHKew98YX6t3MCJ>

- Blaise Pascal as the pioneer of 17th century, managed to create a mechanical calculator called the Pascaline. This was followed by Charles Babbage, introducing the Analytical Engine in the 1930s. The Analytic Engine was a mechanical computer meant for general purposes. It is worth recognising that this was only a concept from Charles Babbage, his ideas were never implemented to an actual machine in his own lifetime.
- Ada Lovelace followed up and worked on algorithms for Analytic Engine. She is the first computer programmer.
- Between the 1930a and 1940s, electromechanical computers were introduced.
- In 1941, Konrad Zuze created Zuze Z3 which was a program-controlled computer. There were also machines called Colossus, which used for code breaking during World War II.

I then learned that, in the 1960s held Mainframe Era where IBM was the major player in the industry. IBM managed to introduce System/360 series. Because of Mainframe’s ability to hold large scales of data, it had favourable conditions for business, large or small organisations. Microsoft, Apple as well as IBM dominated the era between 1980s and 1980s with the inception of personal computers. These machines carried the acronym (PC).

With the introduction of World Wide Web in the 90s, many individuals were able to connect their machines to internet and networking. This enabled computers to share data. Fast moving technology in 2000s reimagined how we use computers today. The Digital era furnished the 2000s onwards, with technology such as AI. Many industries around the globe are now able to communicate with mobile phones. Computers then revolutionised to laptops and tablets. Cloud computing is a key component of evolving technology.

**Session 2 :**

In this session, I learnt about Computer architecture and its components. Firstly, I was introduced to basic principles of Turing machine

**_Turing machine:_**

Introduced by Alan Turing in 1936. This concept is of importance in regard to computer science and shows limitations of what can be computed. Turing machine has components such as State Register, Finite Table Of Instructions, Head and Tape. This is programmable.

**_Classic Von-Neumann Architecture:_**

In the 1940s, John von Neumann designed the classic Von Neumann architecture model. This laid a foundation for modern computing machines. The Von Neumann has key features as well as components, as follows:

- Central Processing Unit (CPU )

This is the part that make calculations, controls data flow and as well implementing instructions.

- Control Unit (CU )

Conducts operations, sorts out and decipher commands from memory.

- Arithmetic/Logic Unit (ALU )

This is well arithmetic, and logic operations are executed

- Memory Unit

Data storage and directives for CPU

Von Neumann contains Input and Output apparatus.

**_Types of Memory:_**

- On CPU

1.Registers-

High speed units that hold provisional data as well as commands when the system is running.

2.Arithmetic Logic Unit-

Tasked to perform operations arithmetic and logic. The arithmetic unit involves mathematical functions.

The Logic operations involve Boolean Algebra logic.

3.Layer 1 cache-

It is a small and high-speed cache designed to handle data that is regularly accessed, transmitted from memory.

4.Layer 2 cache-

It is slower than Layer 1 cache, however it enhances access speed for data required.

5.Memory Management Unit-

Memory Management Unit is designed to hold memory and control address translations. It is a vital part in modern machines.

- Off CPU-

1.SRAM/DRAM

These acronyms translate to Static Random-Access Memory and Dynamic Random-Access Memory. These have different properties and functions.

SRAM is designed to be faster, targeting certain tasks whereas DRAM is built for large streams of data in machines.

2.Removable such as Floppy/SD card/Tape

3.Virtual Memory

When a computer doesn’t have enough RAM, it creates a memory technique by transferring data to hard disk in order to make space available for other programs. When data is required, virtual memory moves data back to RAM.

**X86 vs ARM Architecture**

CPU types:

1.RISC - reduced instruction set computer

\-ARM in Raspberry PI

2.CISC - complex instruction set computer

\-X86 Intel processors in PCs

Binary and Boolean:

I learnt that computers use binary signals 1 and 0 for all of their functions. This is with exception of analogue and quantum computing.

Binary arithmetic is an integral part of computing and Boolean algebra is the foundation of computing.

Binary arithmetic involves the use of mathematical functions while Boolean focuses on “AND” , “OR”, “NOT”

Binary Arithmetic

**Raspberry Pi:**

**Session 3:**

How a computer like Raspberry Pi communicates the outside world:

In this session, I learnt about computer languages and how they are connected to computer’s hardware.

Introduction to Machine Code, Assembly Code and High Level Languages:

Machine Codes refers to computer language that consists of binary code that can be read and interpreted by a machine’s central processing unit. These are made of binary numbers which have directives in addition to data for a computer’s hardware, on how to implement an operation.

I learned that binary machine codes could be implemented directly, however it can be time consuming and there is room for a lot of errors. Programmers have managed introduce a versions that are low level programs equivalent to readable human versions that can be decoded easily. This is are called Assembly Code.

An **_Assembler_** is a program that translates human readable assembler code source changing it into machine code run on the processor .

An **_Assembler_** is a program that translates assembly low level programming language into a machine code. That is executed by a computer’s central processing

**High Level Languages :**

These are programming languages designed for humans to easily write, read and understand. These languages include Python, C, Java, Basic or Java Script.

High Level Languages come in different categories namely **_Interpreted Languages_** and **_Compiled Languages._**

**_Interpreted Languages_** are designed to carry out orders directly. They do not require previous compilation. Examples are Ruby and Java Script. These are easier to write as they can be tested as you proceed,

**_Compiled Languages require_** prior compilation before execution. These include COBOL, CLEO, C++, Pascal

**Open and Closed source programs:**

Closed source program is the type of software where public users are unable to access the source code form. These types of programs are, for example, iOS and Microsoft Windows.

Open source program is whereby the public has access to the source code. These also allow public to edit and share code. Mozilla Firefox is an example of such software.

**Introduction to ARM Assembler and C programming using CPUlator**

CPUlator is a free CPU simulator introduced by Henry Wong. This is a simulator that also functions as a debugger of a computer system that runs inside browser webb. I learned that simulation does not require hardware board to run and debug programs.



TBD
